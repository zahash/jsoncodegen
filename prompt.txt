use serde_json::{Map, Value};
use std::{fmt::Display, ops::Deref};

#[derive(Debug, Clone, PartialEq)]
pub enum Schema {
    Object(Vec<Field>),
    Array(FieldType),
}

#[derive(Debug, Clone, PartialEq)]
pub struct Field {
    pub name: String,
    pub ty: FieldType,
}

#[derive(Debug, Clone, PartialEq)]
pub enum FieldType {
    String,
    Integer,
    Float,
    Boolean,
    Unknown,
    Object(Vec<Field>),
    Union(Vec<FieldType>),
    Array(Box<FieldType>),
    Optional(Box<FieldType>),
}

impl From<Value> for Schema {
    fn from(json: Value) -> Self {
        match json {
            Value::Array(arr) => Self::Array(array(arr)),
            Value::Object(obj) => Self::Object(object(obj)),
            _ => unreachable!("Valid top level Value will always be object or array"),
        }
    }
}

fn object(obj: Map<String, Value>) -> Vec<Field> {
    let mut fields = vec![];

    for (key, value) in obj {
        fields.push(Field {
            name: key,
            ty: field_type(value),
        });
    }

    fields
}

struct FieldTypeAggregator {
    ty: Option<FieldType>,
}

impl FieldTypeAggregator {
    fn new() -> Self {
        Self { ty: None }
    }

    fn add(&mut self, field_type: FieldType) {
        match self.ty.take() {
            None => self.ty = Some(field_type),
            Some(ty) => self.ty = Some(Self::merge(ty, field_type)),
        };
    }

    fn finalize(self) -> FieldType {
        self.ty.unwrap_or(FieldType::Unknown)
    }

    fn merge(existing: FieldType, new: FieldType) -> FieldType {
        match (existing, new) {
            (FieldType::String, FieldType::String) => FieldType::String,
            (FieldType::Integer, FieldType::Integer) => FieldType::Integer,
            (FieldType::Float, FieldType::Float) => FieldType::Float,
            (FieldType::Boolean, FieldType::Boolean) => FieldType::Boolean,
            (FieldType::Unknown, FieldType::Unknown) => FieldType::Unknown,

            (FieldType::String, FieldType::Integer) | (FieldType::Integer, FieldType::String) => {
                FieldType::Union(vec![FieldType::String, FieldType::Integer])
            }
            (FieldType::String, FieldType::Float) | (FieldType::Float, FieldType::String) => {
                FieldType::Union(vec![FieldType::String, FieldType::Float])
            }
            (FieldType::String, FieldType::Boolean) | (FieldType::Boolean, FieldType::String) => {
                FieldType::Union(vec![FieldType::String, FieldType::Boolean])
            }
            (FieldType::Integer, FieldType::Float) | (FieldType::Float, FieldType::Integer) => {
                FieldType::Union(vec![FieldType::Integer, FieldType::Float])
            }
            (FieldType::Integer, FieldType::Boolean) | (FieldType::Boolean, FieldType::Integer) => {
                FieldType::Union(vec![FieldType::Integer, FieldType::Boolean])
            }
            (FieldType::Float, FieldType::Boolean) | (FieldType::Boolean, FieldType::Float) => {
                FieldType::Union(vec![FieldType::Float, FieldType::Boolean])
            }

            (FieldType::String, FieldType::Object(fields))
            | (FieldType::Object(fields), FieldType::String) => {
                FieldType::Union(vec![FieldType::String, FieldType::Object(fields)])
            }
            (FieldType::Integer, FieldType::Object(fields))
            | (FieldType::Object(fields), FieldType::Integer) => {
                FieldType::Union(vec![FieldType::Integer, FieldType::Object(fields)])
            }
            (FieldType::Float, FieldType::Object(fields))
            | (FieldType::Object(fields), FieldType::Float) => {
                FieldType::Union(vec![FieldType::Float, FieldType::Object(fields)])
            }
            (FieldType::Boolean, FieldType::Object(fields))
            | (FieldType::Object(fields), FieldType::Boolean) => {
                FieldType::Union(vec![FieldType::Boolean, FieldType::Object(fields)])
            }

            (FieldType::String, FieldType::Union(mut tys))
            | (FieldType::Union(mut tys), FieldType::String) => {
                if !tys.contains(&FieldType::String) {
                    tys.push(FieldType::String);
                }
                FieldType::Union(tys)
            }
            (FieldType::Integer, FieldType::Union(mut tys))
            | (FieldType::Union(mut tys), FieldType::Integer) => {
                if !tys.contains(&FieldType::Integer) {
                    tys.push(FieldType::Integer);
                }
                FieldType::Union(tys)
            }
            (FieldType::Float, FieldType::Union(mut tys))
            | (FieldType::Union(mut tys), FieldType::Float) => {
                if !tys.contains(&FieldType::Float) {
                    tys.push(FieldType::Float);
                }
                FieldType::Union(tys)
            }
            (FieldType::Boolean, FieldType::Union(mut tys))
            | (FieldType::Union(mut tys), FieldType::Boolean) => {
                if !tys.contains(&FieldType::Boolean) {
                    tys.push(FieldType::Boolean);
                }
                FieldType::Union(tys)
            }

            (FieldType::String, FieldType::Array(ty))
            | (FieldType::Array(ty), FieldType::String) => {
                FieldType::Union(vec![FieldType::String, FieldType::Array(ty)])
            }
            (FieldType::Integer, FieldType::Array(ty))
            | (FieldType::Array(ty), FieldType::Integer) => {
                FieldType::Union(vec![FieldType::Integer, FieldType::Array(ty)])
            }
            (FieldType::Float, FieldType::Array(ty)) | (FieldType::Array(ty), FieldType::Float) => {
                FieldType::Union(vec![FieldType::Float, FieldType::Array(ty)])
            }
            (FieldType::Boolean, FieldType::Array(ty))
            | (FieldType::Array(ty), FieldType::Boolean) => {
                FieldType::Union(vec![FieldType::Boolean, FieldType::Array(ty)])
            }

            (FieldType::Optional(ty), FieldType::Unknown)
            | (FieldType::Unknown, FieldType::Optional(ty)) => FieldType::Optional(ty),
            (ft, FieldType::Unknown) | (FieldType::Unknown, ft) => {
                FieldType::Optional(Box::new(ft))
            }
            (FieldType::String, FieldType::Optional(ty))
            | (FieldType::Optional(ty), FieldType::String) => {
                FieldType::Optional(Box::new(Self::merge(FieldType::String, *ty)))
            }
            (FieldType::Integer, FieldType::Optional(ty))
            | (FieldType::Optional(ty), FieldType::Integer) => {
                FieldType::Optional(Box::new(Self::merge(FieldType::Integer, *ty)))
            }
            (FieldType::Float, FieldType::Optional(ty))
            | (FieldType::Optional(ty), FieldType::Float) => {
                FieldType::Optional(Box::new(Self::merge(FieldType::Float, *ty)))
            }
            (FieldType::Boolean, FieldType::Optional(ty))
            | (FieldType::Optional(ty), FieldType::Boolean) => {
                FieldType::Optional(Box::new(Self::merge(FieldType::Boolean, *ty)))
            }
            (FieldType::Object(fields), FieldType::Optional(ty))
            | (FieldType::Optional(ty), FieldType::Object(fields)) => {
                FieldType::Optional(Box::new(Self::merge(FieldType::Object(fields), *ty)))
            }
            (FieldType::Union(union_types), FieldType::Optional(ty))
            | (FieldType::Optional(ty), FieldType::Union(union_types)) => {
                FieldType::Optional(Box::new(Self::merge(FieldType::Union(union_types), *ty)))
            }
            (FieldType::Array(arr_ty), FieldType::Optional(op_ty))
            | (FieldType::Optional(op_ty), FieldType::Array(arr_ty)) => {
                FieldType::Optional(Box::new(Self::merge(FieldType::Array(arr_ty), *op_ty)))
            }

            (FieldType::Object(existing_fields), FieldType::Object(new_fields)) => {
                FieldType::Object(Self::merge_obj_fields(existing_fields, new_fields))
            }

            (FieldType::Object(obj_fields), FieldType::Union(mut union_types))
            | (FieldType::Union(mut union_types), FieldType::Object(obj_fields)) => {
                match union_types
                    .iter_mut()
                    .filter_map(|ty| match ty {
                        FieldType::Object(existing_obj_fields) => Some(existing_obj_fields),
                        _ => None,
                    })
                    .next()
                {
                    Some(existing_obj_fields) => match obj_fields == *existing_obj_fields {
                        true => FieldType::Union(union_types),
                        false => {
                            let merged_obj_fields =
                                Self::merge_obj_fields(existing_obj_fields.clone(), obj_fields);
                            *existing_obj_fields = merged_obj_fields;
                            FieldType::Union(union_types)
                        }
                    },
                    None => {
                        union_types.push(FieldType::Object(obj_fields));
                        FieldType::Union(union_types)
                    }
                }
            }
            (FieldType::Array(arr_type), FieldType::Union(mut union_types))
            | (FieldType::Union(mut union_types), FieldType::Array(arr_type)) => match union_types
                .iter_mut()
                .filter_map(|ty| match ty {
                    FieldType::Array(existing_arr_ty) => Some(existing_arr_ty),
                    _ => None,
                })
                .next()
            {
                Some(existing_arr_type) => match *existing_arr_type == arr_type {
                    true => FieldType::Union(union_types),
                    false => {
                        let merged_arr_type =
                            Self::merge(existing_arr_type.deref().deref().clone(), *arr_type);
                        *existing_arr_type = Box::new(merged_arr_type);
                        FieldType::Union(union_types)
                    }
                },
                None => {
                    union_types.push(FieldType::Array(arr_type));
                    FieldType::Union(union_types)
                }
            },

            (FieldType::Object(obj_fields), FieldType::Array(arr_ty))
            | (FieldType::Array(arr_ty), FieldType::Object(obj_fields)) => FieldType::Union(vec![
                FieldType::Object(obj_fields),
                FieldType::Array(arr_ty),
            ]),

            (FieldType::Union(existing_types), FieldType::Union(new_types)) => {
                let mut merged_types = existing_types;
                for new_type in new_types {
                    if !merged_types.contains(&new_type) {
                        merged_types.push(new_type);
                    }
                }
                FieldType::Union(merged_types)
            }

            (FieldType::Array(existing_ele_type), FieldType::Array(new_ele_type)) => {
                let merged_ele_type = Self::merge(*existing_ele_type, *new_ele_type);
                FieldType::Array(Box::new(merged_ele_type))
            }

            (FieldType::Optional(existing_ty), FieldType::Optional(new_ty)) => {
                FieldType::Optional(Box::new(Self::merge(*existing_ty, *new_ty)))
            }
        }
    }

    fn merge_obj_fields(mut existing_fields: Vec<Field>, mut new_fields: Vec<Field>) -> Vec<Field> {
        existing_fields = existing_fields
            .into_iter()
            .map(|mut existing_field| {
                match new_fields
                    .iter()
                    .any(|new_field| existing_field.name == new_field.name)
                {
                    true => existing_field,
                    false => match existing_field.ty {
                        FieldType::Unknown | FieldType::Optional(_) => existing_field,
                        _ => {
                            existing_field.ty = FieldType::Optional(Box::new(existing_field.ty));
                            existing_field
                        }
                    },
                }
            })
            .collect();

        new_fields = new_fields
            .into_iter()
            .map(|mut new_field| {
                match existing_fields
                    .iter()
                    .any(|existing_field| existing_field.name == new_field.name)
                {
                    true => new_field,
                    false => match new_field.ty {
                        FieldType::Unknown | FieldType::Optional(_) => new_field,
                        _ => {
                            new_field.ty = FieldType::Optional(Box::new(new_field.ty));
                            new_field
                        }
                    },
                }
            })
            .collect();

        let mut merged_fields = existing_fields;
        for new_field in new_fields {
            match merged_fields.iter_mut().find(|f| f.name == new_field.name) {
                Some(field) => field.ty = Self::merge(field.ty.clone(), new_field.ty),
                None => merged_fields.push(new_field),
            }
        }
        merged_fields
    }
}

fn array(arr: Vec<Value>) -> FieldType {
    let mut agg = FieldTypeAggregator::new();

    for value in arr {
        let field_type = field_type(value);
        agg.add(field_type);
    }

    agg.finalize()
}

fn field_type(value: Value) -> FieldType {
    match value {
        Value::Null => FieldType::Unknown,
        Value::Bool(_) => FieldType::Boolean,
        Value::Number(n) => match n.is_u64() || n.is_i64() {
            true => FieldType::Integer,
            false => FieldType::Float,
        },
        Value::String(_) => FieldType::String,
        Value::Array(arr) => FieldType::Array(Box::new(array(arr))),
        Value::Object(obj) => FieldType::Object(object(obj)),
    }
}

impl Display for Schema {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Schema::Object(fields) => write!(f, "{{{}}}", FieldsDisp(fields)),
            Schema::Array(field_type) => write!(f, "[{}]", field_type),
        }
    }
}

impl Display for Field {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}:{}", self.name, self.ty)
    }
}

impl Display for FieldType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            FieldType::String => write!(f, "str"),
            FieldType::Integer => write!(f, "int"),
            FieldType::Float => write!(f, "float"),
            FieldType::Boolean => write!(f, "bool"),
            FieldType::Unknown => write!(f, "null"),
            FieldType::Object(fields) => write!(f, "{{{}}}", FieldsDisp(fields)),
            FieldType::Union(field_types) => {
                for field_type in field_types {
                    write!(f, "|{}", field_type)?;
                }
                write!(f, "|")
            }
            FieldType::Array(field_type) => write!(f, "[{}]", field_type),
            FieldType::Optional(field_type) => write!(f, "{}?", field_type),
        }
    }
}

struct FieldsDisp<'a>(&'a [Field]);
impl Display for FieldsDisp<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut iter = self.0.iter();
        if let Some(field) = iter.next() {
            write!(f, "{}", field)?;
            for field in iter {
                write!(f, ",{}", field)?;
            }
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use pretty_assertions::assert_eq;

    fn check(json: &str, schema: &str) {
        let json = serde_json::from_str::<Value>(json).expect("invalid json string");
        assert_eq!(schema, format!("{}", Schema::from(json)));
    }

    #[test]
    fn test() {
        // empty structures
        check("{}", "{}");
        check("[]", "[null]");
        check("[null]", "[null]");

        // single primitive arrays
        check("[true]", "[bool]");
        check("[123]", "[int]");
        check("[123.5]", "[float]");
        check(r#"["s"]"#, "[str]");

        // union
        check("[1, 2.5]", "[|int|float|]");
        check(r#"["a", 5]"#, "[|str|int|]");
        check(r#"["s", {"a":1}]"#, "[|str|{a:int}|]");
        check(r#"[{"a":1}, [1]]"#, "[|{a:int}|[int]|]");

        // null
        check("[null, null]", "[null]");

        // optional
        check("[null, 5]", "[int?]");
        check("[5, null]", "[int?]");
        check("[null, null, 5]", "[int?]");
        check("[[1], null]", "[[int]?]");
        check("[null, [1]]", "[[int]?]");

        // optional union
        check("[1, 2.2, null]", "[|int|float|?]");
        check(r#"["s", 1, null]"#, "[|str|int|?]");

        // nested arrays
        check("[[1], [2]]", "[[int]]");
        check(r#"[[1], ["a"]]"#, "[[|str|int|]]");

        // array of objects with disjoint fields
        check(r#"[{"a":1}, {}]"#, "[{a:int?}]");
        check(r#"[{"a":1}, {"b":"x"}]"#, "[{a:int?,b:str?}]");
        check(
            r#"[{"a":1}, {"a":2, "b":"x"}, {"a":2, "c":3.14}]"#,
            "[{a:int,b:str?,c:float?}]",
        );

        // object
        check(r#"{"x": 1}"#, "{x:int}");
        check(r#"{"x": null}"#, "{x:null}");
        check(r#"{"x": [1,2]}"#, "{x:[int]}");
        check(r#"{"x": [1, "a", null]}"#, "{x:[|str|int|?]}");
    }

    #[test]
    fn ecommerce_api_response() {
        check(
            r#"
            {
                "user": {
                    "id": 123,
                    "name": "Alice",
                    "email": "alice@example.com",
                    "verified": true,
                    "address": {
                        "city": "London",
                        "zip": 40512
                    }
                },
                "cart": [
                    {
                        "sku": "SKU-123",
                        "qty": 2,
                        "price": 499.99,
                        "metadata": null
                    },
                    {
                        "sku": "SKU-999",
                        "qty": 1,
                        "price": 1299.50,
                        "metadata": { "color": "red" }
                    }
                ],
                "payment": null,
                "discount_codes": ["HOLIDAY", 2024, null]
            }
            "#,
            "{\
            user:{id:int,name:str,email:str,verified:bool,address:{city:str,zip:int}},\
            cart:[{sku:str,qty:int,price:float,metadata:{color:str}?}],\
            payment:null,\
            discount_codes:[|str|int|?]\
        }",
        );
    }

    #[test]
    fn config_file() {
        check(
            r#"
            {
                "version": "1.0",
                "services": [
                    {"name": "db", "replicas": 2, "env": ["POSTGRES=1", "DEBUG=true"]},
                    {"name": "api", "replicas": 3, "env": null},
                    {"name": "cache", "replicas": 1, "env": ["REDIS=1"]}
                ],
                "features": {
                    "auth": true,
                    "logging": { "level": "debug", "files": ["a.log", "b.log"] },
                    "metrics": null
                }
            }
            "#,
            "{\
                version:str,\
                services:[{name:str,replicas:int,env:[str]?}],\
                features:{auth:bool,logging:{level:str,files:[str]},metrics:null}\
            }",
        );
    }

    #[test]
    fn analytics_events() {
        check(
            r#"
            [
                {"event":"click", "x":10, "y":20},
                {"event":"scroll", "delta": 300},
                {"event":"purchase", "amount": 129.99, "currency":"USD"},
                {"event":"click", "x":5, "y":10, "timestamp":"2025-01-01T12:00Z"}
            ]
            "#,
            "[{\
                event:str,\
                x:int?,y:int?,\
                delta:int?,\
                amount:float?,currency:str?,\
                timestamp:str?\
            }]",
        );
    }
}

use std::{collections::BTreeMap, fmt::Display};

use jsoncodegen_iota::Iota;
use serde_json::Value;

use crate::schema::{Field, FieldType, Schema};

pub type TypeId = usize;

#[derive(Debug, Clone)]
pub struct TypeGraph {
    pub root: TypeId,
    pub nodes: BTreeMap<TypeId, TypeDef>,
}

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub enum TypeDef {
    String,
    Integer,
    Float,
    Boolean,
    Unknown,
    Object(Vec<ObjectField>),
    Union(Vec<TypeId>),
    Array(TypeId),
    Optional(TypeId),
}

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct ObjectField {
    pub name: String,
    pub type_id: TypeId,
}

impl From<Value> for TypeGraph {
    fn from(json: Value) -> Self {
        let schema = Schema::from(json);
        TypeGraph::from(schema)
    }
}

impl From<Schema> for TypeGraph {
    fn from(schema: Schema) -> Self {
        let type_graph = GraphBuilder::new().process_schema(&schema);
        let reduced_type_graph = TypeReducer::new().reduce(type_graph);
        reduced_type_graph
    }
}

#[derive(Default)]
struct GraphBuilder {
    nodes: BTreeMap<TypeId, TypeDef>,
    cache: BTreeMap<TypeDef, TypeId>,
    iota: Iota,
}

impl GraphBuilder {
    fn new() -> Self {
        Self::default()
    }

    fn process_schema(mut self, schema: &Schema) -> TypeGraph {
        let root_type_id = match schema {
            Schema::Object(fields) => self.process_fields(fields),
            Schema::Array(field_type) => {
                let inner_type_id = self.process_field_type(field_type);
                self.intern(TypeDef::Array(inner_type_id))
            }
        };

        TypeGraph {
            root: root_type_id,
            nodes: self.nodes,
        }
    }

    fn process_field_type(&mut self, field_type: &FieldType) -> TypeId {
        match field_type {
            FieldType::String => self.intern(TypeDef::String),
            FieldType::Integer => self.intern(TypeDef::Integer),
            FieldType::Float => self.intern(TypeDef::Float),
            FieldType::Boolean => self.intern(TypeDef::Boolean),
            FieldType::Unknown => self.intern(TypeDef::Unknown),
            FieldType::Object(fields) => self.process_fields(fields),
            FieldType::Union(field_types) => {
                let mut type_ids: Vec<TypeId> = field_types
                    .iter()
                    .map(|ty| self.process_field_type(ty))
                    .collect();
                type_ids.sort();
                self.intern(TypeDef::Union(type_ids))
            }
            FieldType::Array(inner_field_type) => {
                let inner_type_id = self.process_field_type(inner_field_type);
                self.intern(TypeDef::Array(inner_type_id))
            }
            FieldType::Optional(inner_field_type) => {
                let inner_type_id = self.process_field_type(inner_field_type);
                self.intern(TypeDef::Optional(inner_type_id))
            }
        }
    }

    fn process_fields(&mut self, fields: &[Field]) -> TypeId {
        let mut obj_fields = Vec::with_capacity(fields.len());
        for field in fields {
            obj_fields.push(ObjectField {
                name: field.name.clone(),
                type_id: self.process_field_type(&field.ty),
            });
        }
        obj_fields.sort_by(|a, b| a.name.cmp(&b.name));

        self.intern(TypeDef::Object(obj_fields))
    }

    fn intern(&mut self, type_def: TypeDef) -> TypeId {
        match self.cache.get(&type_def) {
            Some(type_id) => *type_id,
            None => {
                let type_id = self.iota.next();
                self.nodes.insert(type_id, type_def.clone());
                self.cache.insert(type_def, type_id);
                type_id
            }
        }
    }
}

#[derive(Default)]
struct TypeReducer {
    reduced_nodes: BTreeMap<TypeId, TypeDef>,
    cache: BTreeMap<TypeDef, TypeId>,
    remaps: Vec<(TypeId, TypeId)>, // original TypeGraph to reduced TypeGraph
    iota: Iota,
}

impl TypeReducer {
    fn new() -> Self {
        Self::default()
    }

    fn reduce(mut self, type_graph: TypeGraph) -> TypeGraph {
        for (type_id, mut type_def) in type_graph.nodes {
            self.remap_type_def(&mut type_def);
            let reduced_type_id = self.reduce_type_def(type_def);
            self.remaps.push((type_id, reduced_type_id));
        }

        let mut root = type_graph.root;
        self.remap_type_id(&mut root);

        TypeGraph {
            root,
            nodes: self.reduced_nodes,
        }
    }

    fn reduce_type_def(&mut self, type_def: TypeDef) -> TypeId {
        match type_def {
            TypeDef::Object(object_fields) => {
                let target_type_ids: Vec<TypeId> = self.reduced_nodes.keys().copied().collect();

                for target_type_id in target_type_ids {
                    if let Some(TypeDef::Object(target_object_fields)) =
                        self.reduced_nodes.get(&target_type_id).cloned()
                    {
                        if let Some(merged_object_fields) =
                            self.merge_object_fields(&target_object_fields, &object_fields)
                        {
                            self.reduced_nodes
                                .insert(target_type_id, TypeDef::Object(merged_object_fields));
                            return target_type_id;
                        }
                    }
                }
                self.intern(TypeDef::Object(object_fields))
            }
            TypeDef::String
            | TypeDef::Integer
            | TypeDef::Float
            | TypeDef::Boolean
            | TypeDef::Unknown
            | TypeDef::Union(_)
            | TypeDef::Array(_)
            | TypeDef::Optional(_) => self.intern(type_def),
        }
    }

    fn merge_object_fields(
        &mut self,
        target: &[ObjectField],
        candidate: &[ObjectField],
    ) -> Option<Vec<ObjectField>> {
        if target.len() != candidate.len() {
            return None;
        }

        target
            .iter()
            .zip(candidate.iter())
            .map(|(target_field, candidate_field)| {
                self.merge_object_field(target_field, candidate_field)
            })
            // collecting Iterator<Item = Option<...>> as Option<Vec<...>>
            // yeilds Some(Vec<...>) only if every iterated item is Some(...)
            // else, None is yeilded
            .collect()
    }

    fn merge_object_field(
        &mut self,
        target: &ObjectField,
        candidate: &ObjectField,
    ) -> Option<ObjectField> {
        if target.name != candidate.name {
            return None;
        } // names are same from here

        if target.type_id == candidate.type_id {
            return Some(target.clone());
        } // types are different from here

        let target_type_def = self.reduced_nodes.get(&target.type_id)?;
        let candidate_type_def = self.reduced_nodes.get(&candidate.type_id)?;

        if let TypeDef::Unknown = target_type_def {
            return Some(ObjectField {
                name: candidate.name.clone(),
                type_id: self.intern(TypeDef::Optional(candidate.type_id)),
            });
        }

        if let TypeDef::Unknown = candidate_type_def {
            return Some(ObjectField {
                name: target.name.clone(),
                type_id: self.intern(TypeDef::Optional(target.type_id)),
            });
        }

        if let TypeDef::Optional(target_inner_type_id) = target_type_def {
            if target_inner_type_id == &candidate.type_id {
                return Some(target.clone());
            }
        }

        if let TypeDef::Optional(candidate_inner_type_id) = candidate_type_def {
            if candidate_inner_type_id == &target.type_id {
                return Some(candidate.clone());
            }
        }

        if let (TypeDef::Optional(target_inner_type_id), TypeDef::Optional(candidate_inner_type_id)) =
            (target_type_def, candidate_type_def)
            && target_inner_type_id != candidate_inner_type_id
        {
            // TODO
        }

        None
    }

    fn intern(&mut self, type_def: TypeDef) -> TypeId {
        match self.cache.get(&type_def) {
            Some(type_id) => *type_id,
            None => {
                let type_id = self.iota.next();
                self.reduced_nodes.insert(type_id, type_def.clone());
                self.cache.insert(type_def, type_id);
                type_id
            }
        }
    }

    fn remap_type_def(&self, type_def: &mut TypeDef) {
        match type_def {
            TypeDef::Object(object_fields) => {
                for object_field in object_fields {
                    self.remap_type_id(&mut object_field.type_id);
                }
            }
            TypeDef::Union(type_ids) => {
                for type_id in type_ids {
                    self.remap_type_id(type_id);
                }
            }
            TypeDef::Array(type_id) | TypeDef::Optional(type_id) => self.remap_type_id(type_id),
            _ => { /* no-op */ }
        }
    }

    fn remap_type_id(&self, type_id: &mut TypeId) {
        for (old, new) in &self.remaps {
            if type_id == old {
                *type_id = *new;
            }
        }
    }
}

impl Display for TypeGraph {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{};", self.root)?;

        let mut iter = self.nodes.iter();
        if let Some((type_id, type_def)) = iter.next() {
            write!(f, "{}:{}", type_id, type_def)?;
            for (type_id, type_def) in iter {
                write!(f, ";{}:{}", type_id, type_def)?;
            }
        }
        Ok(())
    }
}

impl Display for TypeDef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TypeDef::String => write!(f, "str"),
            TypeDef::Integer => write!(f, "int"),
            TypeDef::Float => write!(f, "float"),
            TypeDef::Boolean => write!(f, "bool"),
            TypeDef::Unknown => write!(f, "null"),
            TypeDef::Object(object_fields) => {
                write!(f, "{{{}}}", ObjectFieldsDisplay(object_fields))
            }
            TypeDef::Union(inner_type_ids) => {
                for type_id in inner_type_ids {
                    write!(f, "|{}", type_id)?;
                }
                write!(f, "|")
            }
            TypeDef::Array(inner_type_id) => write!(f, "[{}]", inner_type_id),
            TypeDef::Optional(inner_type_id) => write!(f, "{}?", inner_type_id),
        }
    }
}

impl Display for ObjectField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}:{}", self.name, self.type_id)
    }
}

struct ObjectFieldsDisplay<'a>(&'a [ObjectField]);
impl Display for ObjectFieldsDisplay<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut iter = self.0.iter();
        if let Some(object_field) = iter.next() {
            write!(f, "{}", object_field)?;
            for field in iter {
                write!(f, ",{}", field)?;
            }
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::Value;

    fn schema(json: &str) -> Schema {
        Schema::from(serde_json::from_str::<Value>(json).expect("invalid json string"))
    }

    #[test]
    fn test() {
        let json = r#"
        {
            "val": 1,
            "prev": {
                "val": 2,
                "prev": null,
                "next": null
            },
            "next": {
                "val": 3,
                "prev": null,
                "next": {
                    "val": 4,
                    "prev": null,
                    "next": null
                }
            }
        }
        "#;

        let schema = schema(json);
        println!("{}", schema);

        let type_graph = TypeGraph::from(schema);
        println!("{}", type_graph);
    }
}


use std::{
    collections::{BTreeMap, HashMap, HashSet},
    fmt::Debug,
};

use crate::type_graph::{ObjectField, TypeDef, TypeGraph, TypeId};

#[derive(Debug)]
pub struct NameRegistry<'type_graph> {
    assigned_names: HashMap<TypeId, &'type_graph str>,
}

impl<'type_graph> NameRegistry<'type_graph> {
    pub fn build(type_graph: &'type_graph TypeGraph) -> Self {
        let name_resolver = NameResolver::resolve(type_graph);
        Self {
            assigned_names: name_resolver.assigned_names,
        }
    }

    pub fn assigned_name(&self, type_id: TypeId) -> Option<&str> {
        self.assigned_names.get(&type_id).map(|name| name.as_ref())
    }
}

#[derive(Debug, Default)]
struct NameResolver<'type_graph> {
    names: BTreeMap<TypeId, Vec<&'type_graph str>>,
    assigned_names: HashMap<TypeId, &'type_graph str>,
    visited: HashSet<TypeId>,
}

impl<'type_graph> NameResolver<'type_graph> {
    fn resolve(type_graph: &'type_graph TypeGraph) -> Self {
        let mut name_resolver = Self::default();
        name_resolver.resolve_type_id(type_graph.root, type_graph);
        name_resolver.assign_names();
        name_resolver
    }

    fn resolve_type_id(&mut self, type_id: TypeId, type_graph: &'type_graph TypeGraph) {
        if self.visited.contains(&type_id) {
            return;
        }
        self.visited.insert(type_id);

        if let Some(type_def) = type_graph.nodes.get(&type_id) {
            match type_def {
                TypeDef::Object(object_fields) => {
                    for object_field in object_fields {
                        self.resolve_object_field(object_field, type_graph);
                    }
                }
                TypeDef::Union(inner_type_ids) => {
                    for inner_type_id in inner_type_ids {
                        self.resolve_type_id(*inner_type_id, type_graph)
                    }
                }
                TypeDef::Array(inner_type_id) | TypeDef::Optional(inner_type_id) => {
                    self.resolve_type_id(*inner_type_id, type_graph)
                }
                _ => { /* no-op */ }
            }
        }
    }

    fn resolve_object_field(
        &mut self,
        object_field: &'type_graph ObjectField,
        type_graph: &'type_graph TypeGraph,
    ) {
        if let Some(object_field_type_def) = type_graph.nodes.get(&object_field.type_id) {
            match object_field_type_def {
                TypeDef::Object(nested_object_fields) => {
                    let names = self.names.entry(object_field.type_id).or_default();
                    names.push(&object_field.name);
                    names.sort();
                    names.dedup();
                    for nested_object_field in nested_object_fields {
                        self.resolve_object_field(nested_object_field, type_graph);
                    }
                }
                TypeDef::Union(inner_type_ids) => {
                    let names = self.names.entry(object_field.type_id).or_default();
                    names.push(&object_field.name);
                    names.sort();
                    names.dedup();
                    for inner_type_id in inner_type_ids {
                        self.resolve_type_id(*inner_type_id, type_graph);
                    }
                }
                TypeDef::Array(inner_type_id) | TypeDef::Optional(inner_type_id) => {
                    let names = self.names.entry(*inner_type_id).or_default();
                    names.push(&object_field.name);
                    names.sort();
                    names.dedup();
                    self.resolve_type_id(*inner_type_id, type_graph);
                }
                _ => { /* no-op */ }
            }
        }
    }

    /// Performs maximum assignment of unique names to ids using a DFS-based
    /// augmenting-path algorithm (Kuhn). Result is stored in `self.assigned_names`.
    fn assign_names(&mut self) {
        // Deterministic left side order (ids)
        let ids_order: Vec<usize> = self.names.keys().copied().collect();
        let n_ids = ids_order.len();

        // Map each unique &'type_graph str to an index on the "right" side
        let mut name_to_index: HashMap<&'type_graph str, usize> = HashMap::new();
        let mut unique_names: Vec<&'type_graph str> = Vec::new();

        // adjacency: for each left-index (position in ids_order) store list of right-indexes
        let mut id_to_name_indices: Vec<Vec<usize>> = vec![Vec::new(); n_ids];

        for (left_pos, id) in ids_order.iter().enumerate() {
            if let Some(candidates) = self.names.get(id) {
                let mut seen_local: HashSet<&'type_graph str> = HashSet::new();
                for &name in candidates {
                    // dedupe duplicates inside the same id's list
                    if !seen_local.insert(name) {
                        continue;
                    }
                    let idx = *name_to_index.entry(name).or_insert_with(|| {
                        unique_names.push(name);
                        unique_names.len() - 1
                    });
                    id_to_name_indices[left_pos].push(idx);
                }
            }
        }

        let n_names = unique_names.len();
        // For each name (right node) store Option<left_pos> it's matched to
        let mut name_matched_to: Vec<Option<usize>> = vec![None; n_names];

        // recursive DFS function to find augmenting path for left node `u`
        fn try_assign(
            u: usize,
            id_to_name_indices: &Vec<Vec<usize>>,
            visited: &mut Vec<bool>,
            name_matched_to: &mut Vec<Option<usize>>,
        ) -> bool {
            for &name_idx in &id_to_name_indices[u] {
                if visited[name_idx] {
                    continue;
                }
                visited[name_idx] = true;
                if name_matched_to[name_idx].is_none()
                    || try_assign(
                        name_matched_to[name_idx].unwrap(),
                        id_to_name_indices,
                        visited,
                        name_matched_to,
                    )
                {
                    // match name -> u
                    name_matched_to[name_idx] = Some(u);
                    return true;
                }
            }
            false
        }

        // Try to find a match for each left node
        for u in 0..n_ids {
            let mut visited = vec![false; n_names];
            try_assign(u, &id_to_name_indices, &mut visited, &mut name_matched_to);
        }

        // Build assigned_names map from matches
        self.assigned_names.clear();
        for (name_idx, opt_left_pos) in name_matched_to.into_iter().enumerate() {
            if let Some(left_pos) = opt_left_pos {
                let id = ids_order[left_pos];
                let name = unique_names[name_idx];
                self.assigned_names.insert(id, name);
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test() {
        let json = r#"
        {
            "val": 1,
            "prev": {
                "val": 2,
                "prev": null,
                "next": null
            },
            "next": {
                "val": 3,
                "prev": null,
                "next": {
                    "val": 4,
                    "prev": null,
                    "next": null
                }
            }
        }
        "#;

        // let json = r#"
        //     {
        //         "id": "123",
        //         "name": "John Doe",
        //         "email": "john.doe@example.com",
        //         "address": {
        //             "street": "123 Main St",
        //             "city": "Anytown",
        //             "state": "CA",
        //             "zip": "12345"
        //         }
        //     }
        //     "#;

        // let json = r#"
        //     {
        //         "user": {
        //             "id": 123,
        //             "name": "Alice",
        //             "email": "alice@example.com",
        //             "verified": true,
        //             "address": {
        //                 "city": "London",
        //                 "zip": 40512
        //             }
        //         },
        //         "cart": [
        //             {
        //                 "sku": "SKU-123",
        //                 "qty": 2,
        //                 "price": 499.99,
        //                 "metadata": null
        //             },
        //             {
        //                 "sku": "SKU-999",
        //                 "qty": 1,
        //                 "price": 1299.50,
        //                 "metadata": { "color": "red" }
        //             }
        //         ],
        //         "payment": null,
        //         "discount_codes": ["HOLIDAY", 2024, null]
        //     }
        //     "#;

        let json = serde_json::from_str::<serde_json::Value>(json).expect("invalid json");
        let type_graph = TypeGraph::from(json);
        let name_registry = NameRegistry::build(&type_graph);
        println!("type_graph={}", type_graph);
        println!("name_registry={:?}", name_registry);
    }
}

i want to create SourceGraph from TypeGraph and NameRegistry.

the main goal of this type is to be the actual final type given to
code generators of various languages to generate source code.

it should make the generator's job as easy as possible to write source code.
for eg: the generator might want to create data structures
like classes, structs, enums, interfaces, etc...
those data structures might have any members or fields or invairants
and they might have names associated with them.
and they might have any methods or functions associated with them.

i want the code generator maintainer's job to be as easy as possible.
