i have a project that generates source code represent json file. for serialization and deserialization.

use serde_json::{Map, Value};
use std::{fmt::Display, ops::Deref};

#[derive(Debug, Clone, PartialEq)]
pub enum Schema {
    Object(Vec<Field>),
    Array(FieldType),
}

#[derive(Debug, Clone, PartialEq)]
pub struct Field {
    pub name: String,
    pub ty: FieldType,
}

#[derive(Debug, Clone, PartialEq)]
pub enum FieldType {
    String,
    Integer,
    Float,
    Boolean,
    Unknown,
    Object(Vec<Field>),
    Union(Vec<FieldType>),
    Array(Box<FieldType>),
    Optional(Box<FieldType>),
}

impl From<Value> for Schema {
    fn from(json: Value) -> Self {
        match json {
            Value::Array(arr) => Self::Array(array(arr)),
            Value::Object(obj) => Self::Object(object(obj)),
            _ => unreachable!("Valid top level Value will always be object or array"),
        }
    }
}

fn object(obj: Map<String, Value>) -> Vec<Field> {
    let mut fields = vec![];

    for (key, value) in obj {
        fields.push(Field {
            name: key,
            ty: field_type(value),
        });
    }

    fields
}

struct FieldTypeAggregator {
    ty: Option<FieldType>,
}

impl FieldTypeAggregator {
    fn new() -> Self {
        Self { ty: None }
    }

    fn add(&mut self, field_type: FieldType) {
        match self.ty.take() {
            None => self.ty = Some(field_type),
            Some(ty) => self.ty = Some(Self::merge(ty, field_type)),
        };
    }

    fn finalize(self) -> FieldType {
        self.ty.unwrap_or(FieldType::Unknown)
    }

    fn merge(existing: FieldType, new: FieldType) -> FieldType {
        match (existing, new) {
            (FieldType::String, FieldType::String) => FieldType::String,
            (FieldType::Integer, FieldType::Integer) => FieldType::Integer,
            (FieldType::Float, FieldType::Float) => FieldType::Float,
            (FieldType::Boolean, FieldType::Boolean) => FieldType::Boolean,
            (FieldType::Unknown, FieldType::Unknown) => FieldType::Unknown,

            (FieldType::String, FieldType::Integer) | (FieldType::Integer, FieldType::String) => {
                FieldType::Union(vec![FieldType::String, FieldType::Integer])
            }
            (FieldType::String, FieldType::Float) | (FieldType::Float, FieldType::String) => {
                FieldType::Union(vec![FieldType::String, FieldType::Float])
            }
            (FieldType::String, FieldType::Boolean) | (FieldType::Boolean, FieldType::String) => {
                FieldType::Union(vec![FieldType::String, FieldType::Boolean])
            }
            (FieldType::Integer, FieldType::Float) | (FieldType::Float, FieldType::Integer) => {
                FieldType::Union(vec![FieldType::Integer, FieldType::Float])
            }
            (FieldType::Integer, FieldType::Boolean) | (FieldType::Boolean, FieldType::Integer) => {
                FieldType::Union(vec![FieldType::Integer, FieldType::Boolean])
            }
            (FieldType::Float, FieldType::Boolean) | (FieldType::Boolean, FieldType::Float) => {
                FieldType::Union(vec![FieldType::Float, FieldType::Boolean])
            }

            (FieldType::String, FieldType::Object(fields))
            | (FieldType::Object(fields), FieldType::String) => {
                FieldType::Union(vec![FieldType::String, FieldType::Object(fields)])
            }
            (FieldType::Integer, FieldType::Object(fields))
            | (FieldType::Object(fields), FieldType::Integer) => {
                FieldType::Union(vec![FieldType::Integer, FieldType::Object(fields)])
            }
            (FieldType::Float, FieldType::Object(fields))
            | (FieldType::Object(fields), FieldType::Float) => {
                FieldType::Union(vec![FieldType::Float, FieldType::Object(fields)])
            }
            (FieldType::Boolean, FieldType::Object(fields))
            | (FieldType::Object(fields), FieldType::Boolean) => {
                FieldType::Union(vec![FieldType::Boolean, FieldType::Object(fields)])
            }

            (FieldType::String, FieldType::Union(mut tys))
            | (FieldType::Union(mut tys), FieldType::String) => {
                if !tys.contains(&FieldType::String) {
                    tys.push(FieldType::String);
                }
                FieldType::Union(tys)
            }
            (FieldType::Integer, FieldType::Union(mut tys))
            | (FieldType::Union(mut tys), FieldType::Integer) => {
                if !tys.contains(&FieldType::Integer) {
                    tys.push(FieldType::Integer);
                }
                FieldType::Union(tys)
            }
            (FieldType::Float, FieldType::Union(mut tys))
            | (FieldType::Union(mut tys), FieldType::Float) => {
                if !tys.contains(&FieldType::Float) {
                    tys.push(FieldType::Float);
                }
                FieldType::Union(tys)
            }
            (FieldType::Boolean, FieldType::Union(mut tys))
            | (FieldType::Union(mut tys), FieldType::Boolean) => {
                if !tys.contains(&FieldType::Boolean) {
                    tys.push(FieldType::Boolean);
                }
                FieldType::Union(tys)
            }

            (FieldType::String, FieldType::Array(ty))
            | (FieldType::Array(ty), FieldType::String) => {
                FieldType::Union(vec![FieldType::String, FieldType::Array(ty)])
            }
            (FieldType::Integer, FieldType::Array(ty))
            | (FieldType::Array(ty), FieldType::Integer) => {
                FieldType::Union(vec![FieldType::Integer, FieldType::Array(ty)])
            }
            (FieldType::Float, FieldType::Array(ty)) | (FieldType::Array(ty), FieldType::Float) => {
                FieldType::Union(vec![FieldType::Float, FieldType::Array(ty)])
            }
            (FieldType::Boolean, FieldType::Array(ty))
            | (FieldType::Array(ty), FieldType::Boolean) => {
                FieldType::Union(vec![FieldType::Boolean, FieldType::Array(ty)])
            }

            (FieldType::Optional(ty), FieldType::Unknown)
            | (FieldType::Unknown, FieldType::Optional(ty)) => FieldType::Optional(ty),
            (ft, FieldType::Unknown) | (FieldType::Unknown, ft) => {
                FieldType::Optional(Box::new(ft))
            }
            (FieldType::String, FieldType::Optional(ty))
            | (FieldType::Optional(ty), FieldType::String) => {
                FieldType::Optional(Box::new(Self::merge(FieldType::String, *ty)))
            }
            (FieldType::Integer, FieldType::Optional(ty))
            | (FieldType::Optional(ty), FieldType::Integer) => {
                FieldType::Optional(Box::new(Self::merge(FieldType::Integer, *ty)))
            }
            (FieldType::Float, FieldType::Optional(ty))
            | (FieldType::Optional(ty), FieldType::Float) => {
                FieldType::Optional(Box::new(Self::merge(FieldType::Float, *ty)))
            }
            (FieldType::Boolean, FieldType::Optional(ty))
            | (FieldType::Optional(ty), FieldType::Boolean) => {
                FieldType::Optional(Box::new(Self::merge(FieldType::Boolean, *ty)))
            }
            (FieldType::Object(fields), FieldType::Optional(ty))
            | (FieldType::Optional(ty), FieldType::Object(fields)) => {
                FieldType::Optional(Box::new(Self::merge(FieldType::Object(fields), *ty)))
            }
            (FieldType::Union(union_types), FieldType::Optional(ty))
            | (FieldType::Optional(ty), FieldType::Union(union_types)) => {
                FieldType::Optional(Box::new(Self::merge(FieldType::Union(union_types), *ty)))
            }
            (FieldType::Array(arr_ty), FieldType::Optional(op_ty))
            | (FieldType::Optional(op_ty), FieldType::Array(arr_ty)) => {
                FieldType::Optional(Box::new(Self::merge(FieldType::Array(arr_ty), *op_ty)))
            }

            (FieldType::Object(existing_fields), FieldType::Object(new_fields)) => {
                FieldType::Object(Self::merge_obj_fields(existing_fields, new_fields))
            }

            (FieldType::Object(obj_fields), FieldType::Union(mut union_types))
            | (FieldType::Union(mut union_types), FieldType::Object(obj_fields)) => {
                match union_types
                    .iter_mut()
                    .filter_map(|ty| match ty {
                        FieldType::Object(existing_obj_fields) => Some(existing_obj_fields),
                        _ => None,
                    })
                    .next()
                {
                    Some(existing_obj_fields) => match obj_fields == *existing_obj_fields {
                        true => FieldType::Union(union_types),
                        false => {
                            let merged_obj_fields =
                                Self::merge_obj_fields(existing_obj_fields.clone(), obj_fields);
                            *existing_obj_fields = merged_obj_fields;
                            FieldType::Union(union_types)
                        }
                    },
                    None => {
                        union_types.push(FieldType::Object(obj_fields));
                        FieldType::Union(union_types)
                    }
                }
            }
            (FieldType::Array(arr_type), FieldType::Union(mut union_types))
            | (FieldType::Union(mut union_types), FieldType::Array(arr_type)) => match union_types
                .iter_mut()
                .filter_map(|ty| match ty {
                    FieldType::Array(existing_arr_ty) => Some(existing_arr_ty),
                    _ => None,
                })
                .next()
            {
                Some(existing_arr_type) => match *existing_arr_type == arr_type {
                    true => FieldType::Union(union_types),
                    false => {
                        let merged_arr_type =
                            Self::merge(existing_arr_type.deref().deref().clone(), *arr_type);
                        *existing_arr_type = Box::new(merged_arr_type);
                        FieldType::Union(union_types)
                    }
                },
                None => {
                    union_types.push(FieldType::Array(arr_type));
                    FieldType::Union(union_types)
                }
            },

            (FieldType::Object(obj_fields), FieldType::Array(arr_ty))
            | (FieldType::Array(arr_ty), FieldType::Object(obj_fields)) => FieldType::Union(vec![
                FieldType::Object(obj_fields),
                FieldType::Array(arr_ty),
            ]),

            (FieldType::Union(existing_types), FieldType::Union(new_types)) => {
                let mut merged_types = existing_types;
                for new_type in new_types {
                    if !merged_types.contains(&new_type) {
                        merged_types.push(new_type);
                    }
                }
                FieldType::Union(merged_types)
            }

            (FieldType::Array(existing_ele_type), FieldType::Array(new_ele_type)) => {
                let merged_ele_type = Self::merge(*existing_ele_type, *new_ele_type);
                FieldType::Array(Box::new(merged_ele_type))
            }

            (FieldType::Optional(existing_ty), FieldType::Optional(new_ty)) => {
                FieldType::Optional(Box::new(Self::merge(*existing_ty, *new_ty)))
            }
        }
    }

    fn merge_obj_fields(mut existing_fields: Vec<Field>, mut new_fields: Vec<Field>) -> Vec<Field> {
        existing_fields = existing_fields
            .into_iter()
            .map(|mut existing_field| {
                match new_fields
                    .iter()
                    .find(|new_field| existing_field.name == new_field.name)
                {
                    Some(_) => existing_field,
                    None => {
                        existing_field.ty = FieldType::Optional(Box::new(existing_field.ty));
                        existing_field
                    }
                }
            })
            .collect();

        new_fields = new_fields
            .into_iter()
            .map(|mut new_field| {
                match existing_fields
                    .iter()
                    .find(|existing_field| existing_field.name == new_field.name)
                {
                    Some(_) => new_field,
                    None => {
                        new_field.ty = FieldType::Optional(Box::new(new_field.ty));
                        new_field
                    }
                }
            })
            .collect();

        let mut merged_fields = existing_fields;
        for new_field in new_fields {
            match merged_fields.iter_mut().find(|f| f.name == new_field.name) {
                Some(field) => field.ty = Self::merge(field.ty.clone(), new_field.ty),
                None => merged_fields.push(new_field),
            }
        }
        merged_fields
    }
}

fn array(arr: Vec<Value>) -> FieldType {
    let mut agg = FieldTypeAggregator::new();

    for value in arr {
        let field_type = field_type(value);
        agg.add(field_type);
    }

    agg.finalize()
}

fn field_type(value: Value) -> FieldType {
    match value {
        Value::Null => FieldType::Unknown,
        Value::Bool(_) => FieldType::Boolean,
        Value::Number(n) => match n.is_u64() || n.is_i64() {
            true => FieldType::Integer,
            false => FieldType::Float,
        },
        Value::String(_) => FieldType::String,
        Value::Array(arr) => FieldType::Array(Box::new(array(arr))),
        Value::Object(obj) => FieldType::Object(object(obj)),
    }
}

impl Display for Schema {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Schema::Object(fields) => write!(f, "{{{}}}", FieldsDisp(fields)),
            Schema::Array(field_type) => write!(f, "[{}]", field_type),
        }
    }
}

impl Display for Field {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}:{}", self.name, self.ty)
    }
}

impl Display for FieldType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            FieldType::String => write!(f, "str"),
            FieldType::Integer => write!(f, "int"),
            FieldType::Float => write!(f, "float"),
            FieldType::Boolean => write!(f, "bool"),
            FieldType::Unknown => write!(f, "null"),
            FieldType::Object(fields) => write!(f, "{{{}}}", FieldsDisp(fields)),
            FieldType::Union(field_types) => {
                for field_type in field_types {
                    write!(f, "|{}", field_type)?;
                }
                write!(f, "|")
            }
            FieldType::Array(field_type) => write!(f, "[{}]", field_type),
            FieldType::Optional(field_type) => write!(f, "{}?", field_type),
        }
    }
}

struct FieldsDisp<'a>(&'a [Field]);
impl Display for FieldsDisp<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut iter = self.0.iter();
        if let Some(field) = iter.next() {
            write!(f, "{}", field)?;
            for field in iter {
                write!(f, ",{}", field)?;
            }
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use pretty_assertions::assert_eq;

    fn check(json: &str, schema: &str) {
        let json = serde_json::from_str::<Value>(json).expect("invalid json string");
        assert_eq!(format!("{}", Schema::from(json)), schema);
    }

    #[test]
    fn empty() {
        check("{}", "{}");
        check("[]", "[null]");
    }

    #[test]
    fn array() {
        check(
            r#"
                [
                    "mixed", null, true, 123, 123.23,
                    ["nested", "arr"], ["arr2"], [123], [true, 27, [22.34]],
                    {"k1": "v1", "k3": true}, {"k1": 23, "k3": false}, {"k2": "v2", "k3": true}
                ]
                "#,
            "[|str|bool|int|float|[|str|int|bool|[float]|]|{k1:|str|int|?,k3:bool,k2:str?}|?]",
        );
    }

    #[test]
    fn object() {
        check(
            r#"
                {
                    "a": "amogus",
                    "b": 123,
                    "c": 45.67,
                    "d": true,
                    "e": null,
                    "f": {"n": "nested"},
                    "g": [1, 2],
                    "h": [
                        "mixed", null, true, 123, 123.23,
                        ["nested", "arr"], ["arr2"], [123], [true, 27, [22.34]],
                        {"k1": "v1", "k3": true}, {"k1": 23, "k3": false}, {"k2": "v2", "k3": true}
                    ]
                }
                "#,
            "{a:str,b:int,c:float,d:bool,e:null,f:{n:str},g:[int],\
            h:[|str|bool|int|float|[|str|int|bool|[float]|]|{k1:|str|int|?,k3:bool,k2:str?}|?]}",
        );
    }
}


#[derive(Debug, Default)]
pub struct Iota {
    n: usize,
}

impl Iota {
    pub fn new() -> Self {
        Self { n: 0 }
    }

    pub fn next(&mut self) -> usize {
        let n = self.n;
        self.n += 1;
        n
    }
}


use convert_case::{Case, Casing};

use crate::iota::Iota;

pub fn to_pascal_case_or_unknown(text: &str, iota: &mut Iota) -> String {
    let text = clean(text);
    match text.is_empty() {
        true => format!("Unknown{}", iota.next()),
        false => text.to_case(Case::Pascal),
    }
}

pub fn to_camel_case_or_unknown(text: &str, iota: &mut Iota) -> String {
    let text = clean(text);
    match text.is_empty() {
        true => format!("unknown{}", iota.next()),
        false => text.to_case(Case::Camel),
    }
}

pub fn to_snake_case_or_unknown(text: &str, iota: &mut Iota) -> String {
    let text = clean(text);
    match text.is_empty() {
        true => format!("unknown_{}", iota.next()),
        false => text.to_case(Case::Snake),
    }
}

/// keep only ascii alphanumeric, ascii whitespace and underscore.
/// there will only be atmost one whitespace between two words.
/// there won't be any leading or trailing whitespaces
/// there won't be any leading digits
fn clean(text: &str) -> String {
    let text: String = text.replace(|c: char| !(c.is_ascii_alphanumeric() || c == '_'), " ");
    let segments: Vec<&str> = text
        .split_ascii_whitespace()
        .filter(|s| !s.is_empty())
        .collect();
    let segments = trim_leading_digits(&segments);
    segments.join(" ")
}

fn trim_leading_digits<'s>(segments: &[&'s str]) -> Vec<&'s str> {
    match segments {
        [] => vec![],
        [first, rest @ ..] => {
            let first = first.trim_start_matches(|c: char| c.is_ascii_digit());
            match first.is_empty() {
                true => trim_leading_digits(rest),
                false => {
                    let mut v = vec![first];
                    v.extend(rest);
                    v
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use pretty_assertions::assert_eq;

    struct TestCase<'a> {
        input: &'a str,
        pascal: &'a str,
        camel: &'a str,
        snake: &'a str,
    }

    impl<'a> TestCase<'a> {
        fn assert(self) {
            assert_eq!(
                self.pascal,
                to_pascal_case_or_unknown(self.input, &mut Iota::new()),
                "mismatch pascal"
            );
            assert_eq!(
                self.camel,
                to_camel_case_or_unknown(self.input, &mut Iota::new()),
                "mismatch camel"
            );
            assert_eq!(
                self.snake,
                to_snake_case_or_unknown(self.input, &mut Iota::new()),
                "mismatch snake"
            );
        }
    }

    #[test]
    fn test() {
        TestCase {
            input: "basic",
            pascal: "Basic",
            camel: "basic",
            snake: "basic",
        }
        .assert();

        TestCase {
            input: "RubberDuck",
            pascal: "RubberDuck",
            camel: "rubberDuck",
            snake: "rubber_duck",
        }
        .assert();

        TestCase {
            input: "rubberDuck",
            pascal: "RubberDuck",
            camel: "rubberDuck",
            snake: "rubber_duck",
        }
        .assert();

        TestCase {
            input: "rubber_duck",
            pascal: "RubberDuck",
            camel: "rubberDuck",
            snake: "rubber_duck",
        }
        .assert();

        TestCase {
            input: "",
            pascal: "Unknown0",
            camel: "unknown0",
            snake: "unknown_0",
        }
        .assert();

        TestCase {
            input: "    ",
            pascal: "Unknown0",
            camel: "unknown0",
            snake: "unknown_0",
        }
        .assert();

        TestCase {
            input: "こんにちは",
            pascal: "Unknown0",
            camel: "unknown0",
            snake: "unknown_0",
        }
        .assert();

        TestCase {
            input: "spaces    between",
            pascal: "SpacesBetween",
            camel: "spacesBetween",
            snake: "spaces_between",
        }
        .assert();

        TestCase {
            input: "123digits",
            pascal: "Digits",
            camel: "digits",
            snake: "digits",
        }
        .assert();

        TestCase {
            input: "123 digits",
            pascal: "Digits",
            camel: "digits",
            snake: "digits",
        }
        .assert();

        TestCase {
            input: "   123  56foo88  33  こんにちは  ",
            pascal: "Foo8833",
            camel: "foo8833",
            snake: "foo_88_33",
        }
        .assert();
    }
}


use std::io;

use jsoncodegen::{
    extra::{to_camel_case_or_unknown, to_pascal_case_or_unknown},
    iota::Iota,
    schema::{Field, FieldType, Schema},
};

pub fn codegen(json: serde_json::Value, out: &mut dyn io::Write) -> Result<(), io::Error> {
    let schema = Schema::from(json);
    let mut ctx = Context::new();

    match schema {
        Schema::Object(fields) => ctx.add_class("Root".into(), fields),
        Schema::Array(ty) => {
            ctx.process_field(Field {
                name: "Item".into(),
                ty,
            });
        }
    };

    for class in ctx.classes {
        writeln!(out, "// {}.java", class.name)?;
        writeln!(out, "import com.fasterxml.jackson.annotation.*;")?;

        writeln!(out, "public class {} {{", class.name)?;
        for member_var in &class.vars {
            writeln!(
                out,
                "    private {} {};",
                member_var.type_name, member_var.var_name
            )?;
        }

        for member_var in &class.vars {
            let add_json_property = member_var.original_name != member_var.var_name;
            if add_json_property {
                writeln!(out, "    @JsonProperty(\"{}\")", member_var.original_name)?;
            }
            writeln!(
                out,
                "    public {} get{}() {{ return {}; }}",
                member_var.type_name,
                to_pascal_case_or_unknown(&member_var.var_name, &mut ctx.iota),
                member_var.var_name
            )?;
            if add_json_property {
                writeln!(out, "    @JsonProperty(\"{}\")", member_var.original_name)?;
            }
            writeln!(
                out,
                "    public void set{}({} value) {{ this.{} = value; }}",
                to_pascal_case_or_unknown(&member_var.var_name, &mut ctx.iota),
                member_var.type_name,
                member_var.var_name
            )?;
        }

        writeln!(out, "}}")?;
    }

    for union in ctx.unions {
        writeln!(out, "// {}.java", union.name)?;
        writeln!(out, "import java.io.IOException;")?;
        writeln!(out, "import com.fasterxml.jackson.core.*;")?;
        writeln!(out, "import com.fasterxml.jackson.databind.*;")?;
        writeln!(out, "import com.fasterxml.jackson.databind.annotation.*;")?;

        writeln!(
            out,
            "@JsonSerialize(using = {}.Serializer.class)",
            union.name
        )?;
        writeln!(
            out,
            "@JsonDeserialize(using = {}.Deserializer.class)",
            union.name
        )?;
        writeln!(out, "public class {} {{", union.name)?;

        for union_var in &union.vars {
            writeln!(
                out,
                "    public {} {};",
                union_var.type_name, union_var.var_name
            )?;
        }

        // Serializer
        writeln!(
            out,
            "    static class Serializer extends JsonSerializer<{}> {{",
            union.name
        )?;
        writeln!(
            out,
            "        @Override public void serialize({} value, JsonGenerator generator, SerializerProvider serializer) throws IOException {{",
            union.name
        )?;
        for union_var in &union.vars {
            writeln!(
                out,
                "            if (value.{} != null) {{ generator.writeObject(value.{}); return; }}",
                union_var.var_name, union_var.var_name
            )?;
        }
        writeln!(out, "            generator.writeNull();")?;
        writeln!(out, "        }}")?;
        writeln!(out, "    }}")?;

        // Deserializer
        writeln!(
            out,
            "    static class Deserializer extends JsonDeserializer<{}> {{",
            union.name
        )?;
        writeln!(
            out,
            "        @Override public {} deserialize(JsonParser parser, DeserializationContext ctx) throws IOException {{",
            union.name
        )?;
        writeln!(
            out,
            "            {} value = new {}();",
            union.name, union.name
        )?;
        writeln!(out, "            switch (parser.currentToken()) {{")?;

        writeln!(out, "            case VALUE_NULL: break;")?;
        for union_var in &union.vars {
            match union_var.type_name.as_str() {
                "String" => writeln!(
                    out,
                    "            case VALUE_STRING: value.{} = parser.readValueAs(String.class); break;",
                    union_var.var_name
                )?,
                "Long" => writeln!(
                    out,
                    "            case VALUE_NUMBER_INT: value.{} = parser.readValueAs(Long.class); break;",
                    union_var.var_name
                )?,
                "Double" => writeln!(
                    out,
                    "            case VALUE_NUMBER_FLOAT: value.{} = parser.readValueAs(Double.class); break;",
                    union_var.var_name
                )?,
                "Boolean" => writeln!(
                    out,
                    "            case VALUE_TRUE: case VALUE_FALSE: value.{} = parser.readValueAs(Boolean.class); break;",
                    union_var.var_name
                )?,
                _ if union_var.type_name.starts_with("List") => writeln!(
                    out,
                    "            case START_ARRAY: value.{} = parser.readValueAs({}.class); break;",
                    union_var.var_name, union_var.type_name
                )?,
                _ => writeln!(
                    out,
                    "            case START_OBJECT: value.{} = parser.readValueAs({}.class); break;",
                    union_var.var_name, union_var.type_name
                )?,
            };
        }
        writeln!(
            out,
            "            default: throw new IOException(\"Cannot deserialize {}\");",
            union.name
        )?;
        writeln!(out, "            }}")?;
        writeln!(out, "            return value;")?;
        writeln!(out, "        }}")?;
        writeln!(out, "    }}")?;
        writeln!(out, "}}")?;
    }

    Ok(())
}

struct Context {
    classes: Vec<Class>,
    unions: Vec<Union>,
    iota: Iota,
}

struct Class {
    name: String,
    vars: Vec<MemberVar>,
}

struct MemberVar {
    original_name: String,
    var_name: String,
    type_name: String,
}

struct Union {
    name: String,
    vars: Vec<UnionMemberVar>,
}

struct UnionMemberVar {
    var_name: String,
    type_name: String,
}

impl Context {
    fn new() -> Self {
        Self {
            classes: vec![],
            unions: vec![],
            iota: Iota::new(),
        }
    }

    fn add_class(&mut self, name: String, fields: Vec<Field>) {
        let mut class = Class {
            name: name.clone(),
            vars: vec![],
        };

        for field in fields {
            class.vars.push(self.process_field(field));
        }

        self.classes.push(class);
    }

    fn add_union_class(&mut self, name: String, variants: Vec<FieldType>) {
        let mut union = Union {
            name: name.clone(),
            vars: vec![],
        };

        for variant in variants {
            union
                .vars
                .push(self.process_union_field(name.clone(), variant));
        }

        self.unions.push(union);
    }

    fn process_field(&mut self, field: Field) -> MemberVar {
        match field.ty {
            FieldType::String => MemberVar {
                var_name: to_camel_case_or_unknown(&field.name, &mut self.iota),
                original_name: field.name,
                type_name: "String".into(),
            },
            FieldType::Integer => MemberVar {
                var_name: to_camel_case_or_unknown(&field.name, &mut self.iota),
                original_name: field.name,
                type_name: "Long".into(),
            },
            FieldType::Float => MemberVar {
                var_name: to_camel_case_or_unknown(&field.name, &mut self.iota),
                original_name: field.name,
                type_name: "Double".into(),
            },
            FieldType::Boolean => MemberVar {
                var_name: to_camel_case_or_unknown(&field.name, &mut self.iota),
                original_name: field.name,
                type_name: "Boolean".into(),
            },
            FieldType::Unknown => MemberVar {
                var_name: to_camel_case_or_unknown(&field.name, &mut self.iota),
                original_name: field.name,
                type_name: "Object".into(),
            },
            FieldType::Object(nested_fields) => {
                let nested_class_name = to_pascal_case_or_unknown(&field.name, &mut self.iota);
                self.add_class(nested_class_name.clone(), nested_fields);
                MemberVar {
                    var_name: to_camel_case_or_unknown(&field.name, &mut self.iota),
                    original_name: field.name,
                    type_name: nested_class_name,
                }
            }
            FieldType::Union(types) => {
                let nested_class_name = to_pascal_case_or_unknown(&field.name, &mut self.iota);
                self.add_union_class(nested_class_name.clone(), types);
                MemberVar {
                    var_name: to_camel_case_or_unknown(&field.name, &mut self.iota),
                    original_name: field.name,
                    type_name: nested_class_name,
                }
            }
            FieldType::Array(ty) => {
                let mut member_var = self.process_field(Field {
                    name: field.name,
                    ty: *ty,
                });
                member_var.type_name = format!("List<{}>", member_var.type_name);
                member_var
            }
            FieldType::Optional(ty) => self.process_field(Field {
                name: field.name,
                ty: *ty,
            }),
        }
    }

    fn process_union_field(&mut self, prefix: String, variant: FieldType) -> UnionMemberVar {
        match variant {
            FieldType::String => UnionMemberVar {
                var_name: "strVal".into(),
                type_name: "String".into(),
            },
            FieldType::Integer => UnionMemberVar {
                var_name: "longVal".into(),
                type_name: "Long".into(),
            },
            FieldType::Float => UnionMemberVar {
                var_name: "doubleVal".into(),
                type_name: "Double".into(),
            },
            FieldType::Boolean => UnionMemberVar {
                var_name: "boolVal".into(),
                type_name: "Boolean".into(),
            },
            FieldType::Unknown => UnionMemberVar {
                var_name: "objVal".into(),
                type_name: "Object".into(),
            },
            FieldType::Object(fields) => {
                let member_var = self.process_field(Field {
                    name: prefix + "Clazz",
                    ty: FieldType::Object(fields),
                });

                UnionMemberVar {
                    var_name: member_var.var_name,
                    type_name: member_var.type_name,
                }
            }
            FieldType::Union(types) => {
                let member_var = self.process_field(Field {
                    name: prefix + "Ele",
                    ty: FieldType::Union(types),
                });

                UnionMemberVar {
                    var_name: member_var.var_name,
                    type_name: member_var.type_name,
                }
            }
            FieldType::Array(ty) => {
                let member_var = self.process_field(Field {
                    name: prefix + "Arr",
                    ty: FieldType::Array(ty),
                });

                UnionMemberVar {
                    var_name: member_var.var_name,
                    type_name: member_var.type_name,
                }
            }
            FieldType::Optional(ty) => {
                let member_var = self.process_field(Field {
                    name: prefix + "Opt",
                    ty: FieldType::Optional(ty),
                });

                UnionMemberVar {
                    var_name: member_var.var_name,
                    type_name: member_var.type_name,
                }
            }
        }
    }
}


but how do i determine recursive relations?

right now for the below json
{"a": 1, "b": {"a": 1, "b": null}}

the generated code is
// B.java
import com.fasterxml.jackson.annotation.*;
public class B {
    private Long a;
    private Object b;
    public Long getA() { return a; }
    public void setA(Long value) { this.a = value; }
    public Object getB() { return b; }
    public void setB(Object value) { this.b = value; }
}
// Root.java
import com.fasterxml.jackson.annotation.*;
public class Root {
    private Long a;
    private B b;
    public Long getA() { return a; }
    public void setA(Long value) { this.a = value; }
    public B getB() { return b; }
    public void setB(B value) { this.b = value; }
}

but it should have been

// Root.java
import com.fasterxml.jackson.annotation.*;
public class Root {
    private Long a;
    private Root b;
    public Long getA() { return a; }
    public void setA(Long value) { this.a = value; }
    public Root getB() { return b; }
    public void setB(Root value) { this.b = value; }
}

there is another problem with duplicate classes

{"a": 1, "b": {"a": 1, "b": {"a": 1, "b": null}}}

// B.java
import com.fasterxml.jackson.annotation.*;
public class B {
    private Long a;
    private Object b;
    public Long getA() { return a; }
    public void setA(Long value) { this.a = value; }
    public Object getB() { return b; }
    public void setB(Object value) { this.b = value; }
}
// B.java
import com.fasterxml.jackson.annotation.*;
public class B {
    private Long a;
    private B b;
    public Long getA() { return a; }
    public void setA(Long value) { this.a = value; }
    public B getB() { return b; }
    public void setB(B value) { this.b = value; }
}
// Root.java
import com.fasterxml.jackson.annotation.*;
public class Root {
    private Long a;
    private B b;
    public Long getA() { return a; }
    public void setA(Long value) { this.a = value; }
    public B getB() { return b; }
    public void setB(B value) { this.b = value; }
}

i was thinking of creating another layer of abstraction on top of schema.
like, a high level representation.
that takes Schema as input and emits the high level representation as output.
think what happens in compilers.
how should this representation look like?
while converting from schema to this high level representation,
you do all things like recursive handling, duplicate type handling, etc...


this is my progress so far.

use std::collections::BTreeMap;

use crate::{
    iota::Iota,
    schema::{Field, FieldType, Schema},
};

pub type TypeId = usize;

#[derive(Debug, Clone)]
pub struct CodeGraph {
    pub root: TypeId,
    pub nodes: BTreeMap<TypeId, TypeDef>,
}

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub enum TypeDef {
    String,
    Integer,
    Float,
    Boolean,
    Unknown,
    Object(Vec<CodeField>),
    Union(Vec<TypeId>),
    Array(TypeId),
    Optional(TypeId),
}

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct CodeField {
    pub name: String,
    pub type_id: TypeId,
}

impl From<Schema> for CodeGraph {
    fn from(schema: Schema) -> Self {
        let builder = GraphBuilder::new();
        builder.process_schema(&schema)
    }
}

#[derive(Default)]
struct GraphBuilder {
    nodes: BTreeMap<TypeId, TypeDef>,
    cache: BTreeMap<TypeDef, TypeId>,
    iota: Iota,
}

impl GraphBuilder {
    fn new() -> Self {
        Self::default()
    }

    fn process_schema(mut self, schema: &Schema) -> CodeGraph {
        let root_type_id = match schema {
            Schema::Object(fields) => self.process_fields(fields),
            Schema::Array(field_type) => {
                let inner_type_id = self.process_field_type(field_type);
                self.intern(TypeDef::Array(inner_type_id))
            }
        };

        CodeGraph {
            root: root_type_id,
            nodes: self.nodes,
        }
    }

    fn process_field_type(&mut self, field_type: &FieldType) -> TypeId {
        match field_type {
            FieldType::String => self.intern(TypeDef::String),
            FieldType::Integer => self.intern(TypeDef::Integer),
            FieldType::Float => self.intern(TypeDef::Float),
            FieldType::Boolean => self.intern(TypeDef::Boolean),
            FieldType::Unknown => self.intern(TypeDef::Unknown),
            FieldType::Object(fields) => self.process_fields(fields),
            FieldType::Union(field_types) => {
                let mut type_ids: Vec<TypeId> = field_types
                    .iter()
                    .map(|ty| self.process_field_type(ty))
                    .collect();
                type_ids.sort();
                self.intern(TypeDef::Union(type_ids))
            }
            FieldType::Array(inner_field_type) => {
                let inner_type_id = self.process_field_type(inner_field_type);
                self.intern(TypeDef::Array(inner_type_id))
            }
            FieldType::Optional(inner_field_type) => {
                let inner_type_id = self.process_field_type(inner_field_type);
                self.intern(TypeDef::Optional(inner_type_id))
            }
        }
    }

    fn process_fields(&mut self, fields: &[Field]) -> TypeId {
        let mut code_fields = Vec::with_capacity(fields.len());
        for field in fields {
            code_fields.push(CodeField {
                name: field.name.clone(),
                type_id: self.process_field_type(&field.ty),
            });
        }
        code_fields.sort_by(|a, b| a.name.cmp(&b.name));

        self.intern(TypeDef::Object(code_fields))
    }

    fn intern(&mut self, type_def: TypeDef) -> TypeId {
        match self.cache.get(&type_def) {
            Some(type_id) => *type_id,
            None => {
                let type_id = self.iota.next();
                self.nodes.insert(type_id, type_def.clone());
                self.cache.insert(type_def, type_id);
                type_id
            }
        }
    }
}

now i have to handle and resolve recursive types like this

{
    "val": 1,
    "prev": {
        "val": 2,
        "prev": null,
        "next": null
    },
    "next": {
        "val": 3,
        "prev": null,
        "next": {
            "val": 4,
            "prev": null,
            "next": null
        }
    }
}

right now the code graph looks like this with root = type_id 4
0: Unknown
1: Integer
2: Object([
    CodeField { name: "next", type_id: 0 },
    CodeField { name: "prev", type_id: 0 },
    CodeField { name: "val",  type_id: 1 },
])
3: Object([
    CodeField { name: "next", type_id: 2 },
    CodeField { name: "prev", type_id: 0 },
    CodeField { name: "val",  type_id: 1 },
])
4: Object([
    CodeField { name: "next", type_id: 3 },
    CodeField { name: "prev", type_id: 2 },
    CodeField { name: "val",  type_id: 1 },
])

but it should ideally be this with root = type_id 1
0: TypeDef::Integer
1: TypeDef::Object([
    CodeField { name: "next", type_id: 2 },
    CodeField { name: "prev", type_id: 2 },
    CodeField { name: "val",  type_id: 0 },
])
2: TypeDef::Optional(1)
